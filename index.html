<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Audio Scanner & Big Backup</title>
<style>
  :root{ --bg:#0f1724; --card:#0b1220; --accent:#06b6d4; --muted:#9aa7b2; color-scheme: dark; }
  body{ margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071025 0%,#071425 100%); color:#e6f0f2; min-height:100vh; display:flex; align-items:center; justify-content:center; padding:18px; }
  .app{ width:100%; max-width:860px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:14px; padding:18px; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
  h1{ margin:0 0 8px; font-size:20px; }
  p.lead{ margin:0 0 12px; color:var(--muted); font-size:13px; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
  .btn{ background:linear-gradient(90deg,var(--accent), #7dd3fc); color:#052022; border:none; padding:10px 12px; border-radius:10px; font-weight:600; box-shadow:0 6px 18px rgba(3,7,18,0.5); }
  .btn.alt{ background:transparent; color:var(--accent); border:1px solid rgba(6,182,212,0.18); }
  .status{ font-size:13px; color:var(--muted); margin-bottom:12px; min-height:20px; }
  .progress{ width:100%; background:rgba(255,255,255,0.04); border-radius:8px; height:12px; overflow:hidden; }
  .bar{ height:100%; width:0%; background:linear-gradient(90deg,var(--accent), #7dd3fc); transition:width .2s ease; }
  .list{ max-height:260px; overflow:auto; border-radius:8px; padding:8px; background:rgba(255,255,255,0.02); font-size:13px; color:#cfeff4; }
  .item{ padding:6px 8px; border-radius:6px; margin-bottom:6px; background:rgba(255,255,255,0.01); display:flex; gap:8px; align-items:center; }
  .meta{ color:var(--muted); font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  footer{ margin-top:12px; font-size:12px; color:var(--muted); }
  @media (max-width:520px){
    h1{ font-size:18px; } .btn{ padding:10px; width:100%; }
    .controls{ flex-direction:column; }
  }
</style>
</head>
<body>
<div class="app" role="main">
  <h1>Audio Scanner — Create a big backup of titles</h1>
  <p class="lead">Select a folder (or folders) to scan. The script finds audio files and extracts embedded titles (ID3v2 / ID3v1) when available. Then download a large backup file.</p>

  <div class="controls">
    <!-- folder selection (webkitdirectory) -->
    <label class="btn" for="dirPicker" title="Choose folder(s)">Choose folder</label>
    <input id="dirPicker" type="file" webkitdirectory multiple style="display:none" />
    <button id="startBtn" class="btn alt" disabled>Start scan</button>
    <select id="format" title="Backup format" style="padding:8px;border-radius:8px;background:transparent;color:var(--accent);border:1px solid rgba(255,255,255,0.04)">
      <option value="txt">TXT (simple)</option>
      <option value="csv">CSV</option>
      <option value="json">JSON</option>
    </select>
  </div>

  <div class="status" id="status">No folder chosen.</div>
  <div class="progress" aria-hidden><div class="bar" id="bar"></div></div>

  <div style="margin-top:10px" class="list" id="list"></div>

  <div style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
    <button id="downloadBtn" class="btn" disabled>Download backup</button>
    <button id="clearBtn" class="btn alt" disabled>Clear</button>
  </div>

  <footer>Tip: In Chrome on Android choose "Internal shared storage" and select the top folder you want scanned. The page only accesses files you pick.</footer>
</div>

<script>
/* Audio scanner + lightweight ID3 title extraction.
   - Filters by extension.
   - Reads only small parts of each file (first 10KB for ID3v2 header/frames, last 128 bytes for ID3v1).
   - Builds a large backup and offers it for download.
*/

const allowedExt = ['mp3','m4a','flac','wav','ogg','opus','aac','amr','m4b','mp4'];
const dirPicker = document.getElementById('dirPicker');
const startBtn = document.getElementById('startBtn');
const status = document.getElementById('status');
const listEl = document.getElementById('list');
const bar = document.getElementById('bar');
const downloadBtn = document.getElementById('downloadBtn');
const clearBtn = document.getElementById('clearBtn');
const formatSelect = document.getElementById('format');

let files = [];
let results = [];

dirPicker.addEventListener('change', (e)=>{
  files = Array.from(e.target.files || []);
  if(files.length === 0){
    status.textContent = 'No folder chosen.';
    startBtn.disabled = true;
    return;
  }
  // Filter by extension presence (we keep them now; user may want to scan only audio)
  status.textContent = files.length + ' items selected. Click "Start scan" to find audio files.';
  startBtn.disabled = false;
  listEl.innerHTML = '';
  bar.style.width = '0%';
  results = [];
  downloadBtn.disabled = true;
  clearBtn.disabled = true;
});

// helper: get extension
function extOf(name){
  const m = name.toLowerCase().split('.').pop();
  return m || '';
}

// read slice as ArrayBuffer
async function readSlice(file, start, end){
  const slice = file.slice(start, end);
  return await slice.arrayBuffer();
}

// parse ID3v2 for TIT2 (title). We read the first bytes and frames until found or until bytes limit.
function parseID3v2Title(buf){
  const dv = new DataView(buf);
  // ID3 header: "ID3" (0-2), ver(2), flags(3), size(4-7) (syncsafe)
  if (buf.byteLength < 10) return null;
  if (String.fromCharCode(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2)) !== 'ID3') return null;
  const major = dv.getUint8(3); // version
  // size syncsafe (4 bytes)
  function syncsafeToSize(b0,b1,b2,b3){ return (b0<<21) | (b1<<14) | (b2<<7) | b3; }
  const tagSize = syncsafeToSize(dv.getUint8(6), dv.getUint8(7), dv.getUint8(8), dv.getUint8(9));
  // frames start at offset 10
  let offset = 10;
  // limit scanning to tagSize or buffer length
  const limit = Math.min(tagSize + 10, buf.byteLength);
  while (offset + 10 <= limit){
    // frame id 4 chars
    const id = String.fromCharCode(dv.getUint8(offset), dv.getUint8(offset+1), dv.getUint8(offset+2), dv.getUint8(offset+3));
    // frame size depends on version: v2.3 uses 32-bit int, v2.4 uses syncsafe; we'll handle common case
    let frameSize = dv.getUint32(offset+4);
    if (frameSize <= 0 || frameSize > 10_000_000) {
      // sanity: if frame size suspicious, break
      break;
    }
    const frameHeaderSize = 10;
    if (id === 'TIT2' || id === 'TIT3' || id === 'TT2') {
      // text frame — encoding byte then text
      const textStart = offset + frameHeaderSize + 1;
      const textLen = frameSize - 1;
      if (textStart + textLen <= buf.byteLength){
        const bytes = new Uint8Array(buf, offset + frameHeaderSize + 1, textLen);
        // encoding 0 = ISO-8859-1, 1 = UTF-16 with BOM, 3 = UTF-8
        const encoding = dv.getUint8(offset + frameHeaderSize);
        try {
          if (encoding === 3) {
            return new TextDecoder('utf-8').decode(bytes).replace(/\0/g,'').trim();
          } else if (encoding === 1) {
            // utf-16 with BOM
            return new TextDecoder('utf-16').decode(bytes).replace(/\0/g,'').trim();
          } else {
            return new TextDecoder('iso-8859-1').decode(bytes).replace(/\0/g,'').trim();
          }
        } catch (err) {
          return null;
        }
      }
    }
    offset += frameHeaderSize + frameSize;
  }
  return null;
}

// parse ID3v1 at file end (128 bytes)
function parseID3v1Title(buf){
  if (buf.byteLength < 128) return null;
  const dv = new DataView(buf);
  const tag = String.fromCharCode(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2));
  if (tag !== 'TAG') return null;
  // title bytes 3-32 (30 bytes)
  const bytes = new Uint8Array(buf, 3, 30);
  try {
    return new TextDecoder('iso-8859-1').decode(bytes).replace(/\0/g,'').trim();
  } catch(e){
    return null;
  }
}

// Main scan
startBtn.addEventListener('click', async ()=>{
  if(files.length === 0) return;
  startBtn.disabled = true;
  dirPicker.disabled = true;
  results = [];
  listEl.innerHTML = '';
  status.textContent = 'Scanning files for audio...';
  // filter files by extension
  const audioFiles = files.filter(f => allowedExt.includes(extOf(f.name)));
  if(audioFiles.length === 0){
    status.textContent = 'No audio files found in selected folders.';
    startBtn.disabled = false;
    dirPicker.disabled = false;
    return;
  }
  status.textContent = `Found ${audioFiles.length} audio file(s). Extracting titles...`;
  let processed = 0;
  for(const f of audioFiles){
    try {
      // Try ID3v2 in first ~64KB (enough for frames)
      const firstSlice = Math.min(64 * 1024, f.size); // 64KB cap
      const bufStart = await readSlice(f, 0, firstSlice);
      let title = parseID3v2Title(bufStart);
      if(!title){
        // try ID3v1 from last 128 bytes
        const tailStart = Math.max(0, f.size - 128);
        const bufTail = await readSlice(f, tailStart, f.size);
        title = parseID3v1Title(bufTail);
      }
      if(!title) title = f.name.replace(/\.[^/.]+$/, ''); // fallback: filename without extension
      const relative = f.webkitRelativePath || f.name;
      results.push({ path: relative, filename: f.name, title: title, size: f.size });
      // update list UI (keep last 200 items to avoid DOM bloat)
      const item = document.createElement('div'); item.className = 'item';
      item.innerHTML = `<div style="flex:1"><strong>${escapeHtml(title)}</strong><div class="meta">${escapeHtml(relative)}</div></div><div style="min-width:90px;text-align:right" class="meta">${humanFileSize(f.size)}</div>`;
      listEl.prepend(item);
      if(listEl.children.length > 200) listEl.removeChild(listEl.lastChild);
    } catch(err){
      console.error('Error reading file', f.name, err);
      results.push({ path: f.webkitRelativePath || f.name, filename: f.name, title: '(error reading)', size: f.size });
    }
    processed++;
    bar.style.width = Math.round((processed/audioFiles.length)*100) + '%';
    status.textContent = `Processed ${processed} / ${audioFiles.length}`;
    // yield to UI
    await new Promise(r=>setTimeout(r, 1));
  }

  status.textContent = `Done. ${results.length} audio item(s) collected. Ready to download.`;
  startBtn.disabled = false;
  dirPicker.disabled = false;
  downloadBtn.disabled = false;
  clearBtn.disabled = false;
});

// download as chosen format
downloadBtn.addEventListener('click', ()=>{
  if(results.length === 0) return;
  const fmt = formatSelect.value;
  let blob, name;
  const now = new Date().toISOString().replace(/[:.]/g,'-');
  if(fmt === 'json'){
    blob = new Blob([JSON.stringify(results, null, 2)], {type:'application/json'});
    name = `audio-backup-${now}.json`;
  } else if(fmt === 'csv'){
    const header = ['path','filename','title','size'];
    const rows = results.map(r => header.map(k => csvEscape(String(r[k]===undefined?'':r[k]))).join(','));
    const csv = header.join(',') + '\n' + rows.join('\n');
    blob = new Blob([csv], {type:'text/csv'});
    name = `audio-backup-${now}.csv`;
  } else {
    // txt: each line: title || path
    const lines = results.map(r => `${r.title} || ${r.path}`);
    blob = new Blob([lines.join('\n')], {type:'text/plain'});
    name = `audio-backup-${now}.txt`;
  }
  // create download link
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name;
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 30000);
});

// clear data
clearBtn.addEventListener('click', ()=>{
  files = []; results = [];
  dirPicker.value = '';
  listEl.innerHTML = '';
  status.textContent = 'Cleared.';
  bar.style.width = '0%';
  downloadBtn.disabled = true;
  clearBtn.disabled = true;
  startBtn.disabled = true;
});

// helpers
function humanFileSize(bytes){
  const units=['B','KB','MB','GB','TB'];
  let i=0; let v=bytes;
  while(v>=1024 && i<units.length-1){ v/=1024; i++; }
  return v.toFixed(v<10?2:1) + ' ' + units[i];
}
function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]); }
function csvEscape(s){ return `"${s.replace(/"/g,'""')}"`; }
</script>
</body>
</html>
